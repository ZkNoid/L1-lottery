{
  "method": "GET",
  "baseURL": "https://random-data-api.com/api/number/random_number",
  "path": "number",
  "zkapp": "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nimport { Field, MerkleMap, Poseidon, PublicKey, SmartContract, State, Struct, UInt32, ZkProgram, method, state, } from 'o1js';\nimport { BLOCK_PER_ROUND, ZkOnCoordinatorAddress } from '../constants.js';\nimport { ZkonZkProgram, ZkonRequestCoordinator, ExternalRequestEvent, } from 'zkon-zkapp';\nimport { getIPFSCID } from '../util.js';\nconst emptyMapRoot = new MerkleMap().getRoot();\nexport let ZkonProof_ = ZkProgram.Proof(ZkonZkProgram);\nexport class ZkonProof extends ZkonProof_ {\n}\nexport class CommitValue extends Struct({\n    value: Field,\n    salt: Field,\n}) {\n    hash() {\n        return Poseidon.hash([this.value, this.salt]);\n    }\n}\nconst { hashPart1, hashPart2 } = getIPFSCID();\nconst coordinatorAddress = ZkOnCoordinatorAddress;\nconst owner = PublicKey.fromBase58('B62qjGsPY47SMkTykivPBAU3riS9gvMMrGr7ve6ynoHJNBzAhQmtoBn');\nexport class RandomManager extends SmartContract {\n    constructor() {\n        super(...arguments);\n        this.startSlot = State();\n        this.commit = State();\n        this.result = State();\n        this.curRandomValue = State();\n        this.events = {\n            requested: ExternalRequestEvent,\n        };\n    }\n    // init() {\n    //   super.init();\n    //   // assert(\n    //   //   Bool(false),\n    //   //   'This contract is supposed to be deployed from factory. No init call there'\n    //   // );\n    // }\n    /**\n     * @notice Commit hidden value.\n     * @dev Only hash o value and salt is stored. So value is hidden.\n     *\n     * @param commitValue Commit value = value + slot.\n     *\n     */\n    async commitValue(commitValue) {\n        this.permissionCheck();\n        // Add time check\n        const currentCommit = this.commit.getAndRequireEquals();\n        currentCommit.assertEquals(Field(0), 'Already committed');\n        this.commit.set(commitValue.hash());\n        await this.callZkon();\n    }\n    /*\n  \n    /**\n     * @notice Reveal number committed previously.\n     * @dev This function can be called only after oracle provided its random value\n     *\n     * @param commitValue Commit value = value + slot.\n     *\n     */\n    async reveal(commitValue) {\n        this.permissionCheck();\n        const result = this.result.getAndRequireEquals();\n        result.assertEquals(Field(0), 'reveal: Result already computed');\n        // Check VRF computed\n        const curRandomValue = this.curRandomValue.getAndRequireEquals();\n        // Check is ommitted for a while\n        // curRandomValue.assertGreaterThan(Field(0), 'reveal: No random value');\n        // Check commit\n        const commit = this.commit.getAndRequireEquals();\n        commit.assertEquals(commitValue.hash(), 'reveal: wrong commit value');\n        // Check round is over\n        this.checkRoundPass();\n        // Compute result\n        const resultValue = Poseidon.hash([commitValue.value, curRandomValue]);\n        // Update result\n        this.result.set(resultValue);\n    }\n    /**\n     * @notice Sends request to ZKOn oracle.\n     * @dev Request body is stored on IPFS.\n     *\n     */\n    async callZkon() {\n        let curRandomValue = this.curRandomValue.getAndRequireEquals();\n        curRandomValue.assertEquals(Field(0), 'random value have already been computed');\n        const coordinator = new ZkonRequestCoordinator(coordinatorAddress);\n        const requestId = await coordinator.sendRequest(this.address, hashPart1, hashPart2);\n        const event = new ExternalRequestEvent({\n            id: requestId,\n            hash1: hashPart1,\n            hash2: hashPart2,\n        });\n        this.emitEvent('requested', event);\n    }\n    /**\n     * @notice Callback function for ZKOn response\n     *\n     */\n    async receiveZkonResponse(requestId, proof) {\n        let curRandomValue = this.curRandomValue.getAndRequireEquals();\n        curRandomValue.assertEquals(Field(0), 'receiveZkonResponse: prev random value was not consumed. Call reveal first');\n        const coordinator = new ZkonRequestCoordinator(coordinatorAddress);\n        await coordinator.recordRequestFullfillment(requestId, proof);\n        this.curRandomValue.set(proof.publicInput.dataField);\n    }\n    /**\n     * @notice Checks that sender is the owner of the contract.\n     *\n     */\n    permissionCheck() {\n        this.sender.getAndRequireSignature().assertEquals(owner);\n    }\n    /**\n     * @notice Checks that specified round have already passed.\n     *\n     * @param round Round to check\n     */\n    checkRoundPass() {\n        const startSlot = this.startSlot.getAndRequireEquals();\n        this.network.globalSlotSinceGenesis.requireBetween(startSlot.add(BLOCK_PER_ROUND), UInt32.MAXINT());\n    }\n}\n__decorate([\n    state(UInt32),\n    __metadata(\"design:type\", Object)\n], RandomManager.prototype, \"startSlot\", void 0);\n__decorate([\n    state(Field),\n    __metadata(\"design:type\", Object)\n], RandomManager.prototype, \"commit\", void 0);\n__decorate([\n    state(Field),\n    __metadata(\"design:type\", Object)\n], RandomManager.prototype, \"result\", void 0);\n__decorate([\n    state(Field),\n    __metadata(\"design:type\", Object)\n], RandomManager.prototype, \"curRandomValue\", void 0);\n__decorate([\n    method,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [CommitValue]),\n    __metadata(\"design:returntype\", Promise)\n], RandomManager.prototype, \"commitValue\", null);\n__decorate([\n    method,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [CommitValue]),\n    __metadata(\"design:returntype\", Promise)\n], RandomManager.prototype, \"reveal\", null);\n__decorate([\n    method,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Field, ZkonProof]),\n    __metadata(\"design:returntype\", Promise)\n], RandomManager.prototype, \"receiveZkonResponse\", null);\n//# sourceMappingURL=RandomManager.js.map"
}