{
  "method": "GET",
  "baseURL": "https://quantum-random.com/quantum",
  "path": "seed",
  "zkapp": "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nimport { Field, MerkleMap, MerkleMapWitness, Poseidon, PublicKey, SmartContract, State, Struct, UInt32, ZkProgram, method, state, } from 'o1js';\nimport { BLOCK_PER_ROUND } from '../constants.js';\nimport { convertToUInt32 } from '../util.js';\nimport { ZkonZkProgram, ZkonRequestCoordinator, ExternalRequestEvent, } from 'zkon-zkapp';\nimport { getIPFSCID } from '../../scripts/utils.js';\nconst emptyMapRoot = new MerkleMap().getRoot();\nexport let ZkonProof_ = ZkProgram.Proof(ZkonZkProgram);\nexport class ZkonProof extends ZkonProof_ {\n}\nexport class CommitValue extends Struct({\n    value: Field,\n    salt: Field,\n}) {\n    hash() {\n        return Poseidon.hash([this.value, this.salt]);\n    }\n}\nconst { hashPart1, hashPart2 } = getIPFSCID();\n// Add events\nexport function getRandomManager(owner, coordinatorAddress) {\n    class RandomManager extends SmartContract {\n        constructor() {\n            super(...arguments);\n            this.commitRoot = State();\n            this.resultRoot = State();\n            this.curRandomValue = State();\n            this.startSlot = State();\n            this.events = {\n                requested: ExternalRequestEvent,\n            };\n        }\n        init() {\n            super.init();\n            this.commitRoot.set(emptyMapRoot);\n            this.resultRoot.set(emptyMapRoot);\n        }\n        /**\n         * @notice Inital set of start slot.\n         * @dev It should be equal to startBlock on PLottery. Called only once.\n         *\n         * @param startSlot start slot value.\n         *\n         */\n        async setStartSlot(startSlot) {\n            this.permissionCheck();\n            this.startSlot.getAndRequireEquals().assertEquals(UInt32.from(0));\n            this.startSlot.set(startSlot);\n        }\n        /**\n         * @notice Commit hidden value.\n         * @dev Only hash o value and salt is stored. So value is hidden.\n         *\n         * @param commitValue Commit value = value + slot.\n         * @param commitWitness Witness of commit tree.\n         *\n         */\n        async commit(commitValue, commitWitness) {\n            this.permissionCheck();\n            const [prevCommitRoot, round] = commitWitness.computeRootAndKey(Field(0));\n            this.checkRoundDoNotEnd(convertToUInt32(round));\n            this.commitRoot\n                .getAndRequireEquals()\n                .assertEquals(prevCommitRoot, 'commit: Wrong commit witness');\n            const [newCommitRoot] = commitWitness.computeRootAndKey(commitValue.hash());\n            this.commitRoot.set(newCommitRoot);\n        }\n        /**\n         * @notice Reveal number commited previously.\n         * @dev This function can be called only after oracle provided its random value\n         *\n         * @param commitValue Commit value = value + slot.\n         * @param commitWitness Witness of commit tree.\n         * @param resultWitness Witness of result tree.\n         *\n         */\n        async reveal(commitValue, commitWitness, resultWitness) {\n            this.permissionCheck();\n            // Check VRF computed\n            const curRandomValue = this.curRandomValue.getAndRequireEquals();\n            curRandomValue.assertGreaterThan(Field(0), 'reveal: No random value in stash');\n            // Check commit witness\n            const [prevCommitRoot, round] = commitWitness.computeRootAndKey(commitValue.hash());\n            this.commitRoot\n                .getAndRequireEquals()\n                .assertEquals(prevCommitRoot, 'reveal: Wrong commit witness');\n            // Check result witness\n            const [prevResultRoot, resultRound] = resultWitness.computeRootAndKey(Field(0));\n            this.resultRoot\n                .getAndRequireEquals()\n                .assertEquals(prevResultRoot, 'reveal: wrong result witness');\n            round.assertEquals(resultRound, 'reveal: Round for commit and result should be equal');\n            // Check round is over\n            this.checkRoundPass(convertToUInt32(round));\n            // Compute result\n            const resultValue = Poseidon.hash([commitValue.value, curRandomValue]);\n            // Update result\n            const [newResultRoot] = resultWitness.computeRootAndKey(resultValue);\n            this.resultRoot.set(newResultRoot);\n            // Consume random value\n            this.curRandomValue.set(Field(0));\n        }\n        /**\n         * @notice Sends request to ZKOn oracle.\n         * @dev Request body is stored on IPFS.\n         *\n         */\n        async callZkon() {\n            let curRandomValue = this.curRandomValue.getAndRequireEquals();\n            curRandomValue.assertEquals(Field(0), 'receiveZkonResponse: prev random value was not consumed. Call reveal first');\n            const coordinator = new ZkonRequestCoordinator(coordinatorAddress);\n            const requestId = await coordinator.sendRequest(this.address, hashPart1, hashPart2);\n            const event = new ExternalRequestEvent({\n                id: requestId,\n                hash1: hashPart1,\n                hash2: hashPart2,\n            });\n            this.emitEvent('requested', event);\n        }\n        /**\n         * @notice Callback function for ZKOn response\n         *\n         */\n        async receiveZkonResponse(requestId, proof) {\n            let curRandomValue = this.curRandomValue.getAndRequireEquals();\n            curRandomValue.assertEquals(Field(0), 'receiveZkonResponse: prev random value was not consumed. Call reveal first');\n            const coordinator = new ZkonRequestCoordinator(coordinatorAddress);\n            await coordinator.recordRequestFullfillment(requestId, proof);\n            this.curRandomValue.set(proof.publicInput.dataField);\n        }\n        /**\n         * @notice Checks that sender is the owner of the contract.\n         *\n         */\n        permissionCheck() {\n            this.sender.getAndRequireSignature().assertEquals(owner);\n        }\n        /**\n         * @notice Checks that specified round have already passed.\n         *\n         * @param round Round to check\n         */\n        checkRoundPass(round) {\n            const startBlock = this.startSlot.getAndRequireEquals();\n            this.network.globalSlotSinceGenesis.requireBetween(startBlock.add(round.add(1).mul(BLOCK_PER_ROUND)), UInt32.MAXINT());\n        }\n        /**\n         * @notice Checks that round have not ended yet\n         *\n         * @param round Round to check\n         */\n        checkRoundDoNotEnd(round) {\n            const startBlock = this.startSlot.getAndRequireEquals();\n            this.network.globalSlotSinceGenesis.requireBetween(UInt32.from(0), startBlock.add(round.add(1).mul(BLOCK_PER_ROUND)));\n        }\n    }\n    __decorate([\n        state(Field),\n        __metadata(\"design:type\", Object)\n    ], RandomManager.prototype, \"commitRoot\", void 0);\n    __decorate([\n        state(Field),\n        __metadata(\"design:type\", Object)\n    ], RandomManager.prototype, \"resultRoot\", void 0);\n    __decorate([\n        state(Field),\n        __metadata(\"design:type\", Object)\n    ], RandomManager.prototype, \"curRandomValue\", void 0);\n    __decorate([\n        state(UInt32),\n        __metadata(\"design:type\", Object)\n    ], RandomManager.prototype, \"startSlot\", void 0);\n    __decorate([\n        method,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [UInt32]),\n        __metadata(\"design:returntype\", Promise)\n    ], RandomManager.prototype, \"setStartSlot\", null);\n    __decorate([\n        method,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [CommitValue,\n            MerkleMapWitness]),\n        __metadata(\"design:returntype\", Promise)\n    ], RandomManager.prototype, \"commit\", null);\n    __decorate([\n        method,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [CommitValue,\n            MerkleMapWitness,\n            MerkleMapWitness]),\n        __metadata(\"design:returntype\", Promise)\n    ], RandomManager.prototype, \"reveal\", null);\n    __decorate([\n        method,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", Promise)\n    ], RandomManager.prototype, \"callZkon\", null);\n    __decorate([\n        method,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [Field, ZkonProof]),\n        __metadata(\"design:returntype\", Promise)\n    ], RandomManager.prototype, \"receiveZkonResponse\", null);\n    return RandomManager;\n}\nexport function getMockedRandomManager(owner) {\n    class MockedRandomManager extends getRandomManager(owner, PublicKey.empty()) {\n        async mockReceiveZkonResponse(newValue) {\n            this.curRandomValue.set(newValue);\n        }\n    }\n    __decorate([\n        method,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [Field]),\n        __metadata(\"design:returntype\", Promise)\n    ], MockedRandomManager.prototype, \"mockReceiveZkonResponse\", null);\n    return MockedRandomManager;\n}\n//# sourceMappingURL=RandomManager.js.map"
}